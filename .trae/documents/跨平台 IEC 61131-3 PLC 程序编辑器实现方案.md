## 核心目标
- 以 .NET 8 为后端、React 为前端实现跨平台（Win/macOS/Linux）PLC 程序编辑器。
- 完整支持 ST 与 FBD 的编辑、编译、仿真；提供 LSP 能力（补全/跳转/诊断）。
- 导入/导出符合 PLCopen TC6 XML 标准，主流支持 PLCopen 的编辑器可互导（如 CODESYS、TwinCAT、Automation Studio）。

## 架构与技术栈
- 前端（UI）：React + TypeScript（Vite 构建）、Monaco Editor（ST）、React Flow（FBD）。
- 后端（核心）：.NET 8（C#）实现解析器、IR、编译器、仿真运行时、PLCopen XML 映射与 LSP；ASP.NET Core Minimal API + SignalR/WebSocket 提供服务。
- 桌面封装：Electron + electron-builder（跨平台打包）；启动时 Electron 进程拉起后端（Kestrel）并以本机端口通信。
- 通信：HTTP（项目/文件服务）+ WebSocket/SignalR（编辑器交互、诊断、仿真数据流）。

## 项目结构
- `src/backend/PlcIde.sln`
  - `Plc.Language.St`：ST 词法/语法/AST（ANTLR4 C# 目标或 Pidgin/Superpower 手写解析）。
  - `Plc.Language.Fbd`：FBD 图模型（块/端口/连线/库/验证）。
  - `Plc.Ir`：统一 IR（ST/FBD 映射、任务/程序/调度元数据）。
  - `Plc.Compiler`：类型检查、拓扑排序、静态分析、可执行计划生成。
  - `Plc.Runtime.Sim`：仿真运行时（scan cycle、定时器/计数器、I/O 适配、断点/步进）。
  - `Plc.Xml.Plcopen`：PLCopen TC6 XML 的导入/导出（XSD 校验、AST/IR 映射）。
  - `Plc.Lsp.St`：ST 语言服务器（基于 LSP 协议的补全/跳转/诊断）。
  - `Plc.Server`：ASP.NET Core Minimal API + SignalR，整合各模块对外提供服务。
- `src/frontend`
  - React 应用（Vite + TS）：ST 编辑器（Monaco）、FBD 编辑器（React Flow）、仿真视图、项目管理与构建面板。
- `src/shell`
  - Electron 应用：进程管理（拉起后端）、菜单/托盘、升级、日志；electron-builder 打包。
- `tests`
  - .NET xUnit（解析/类型/编译/仿真）、前端 Vitest（组件与交互）。

## ST 支持
- 语法覆盖：程序/功能块/函数、变量区（`VAR`/`VAR_INPUT`/`VAR_OUTPUT` 等）、控制流、表达式、库块调用。
- 类型系统：基础类型（BOOL/INT/REAL/STRING/TIME）、数组/结构/枚举、隐式/显式转换规则。
- 语言服务：基于 LSP 的诊断、跳转定义、查找引用、重命名、智能补全、悬浮类型与签名。
- 解析器实现：优先采用 ANTLR4（C# 运行时成熟，维护成本低），同时预留手写解析以优化性能路径。

## FBD 支持
- 交互图编辑：拖拽库块、端口连线、对齐与网格、缩放/平移、撤销/重做、参数编辑。
- 语义验证：类型/方向检查、环路检测；通过显式状态/寄存器块支持合法反馈回路。
- 库与扩展：标准库块（`TON`/`TOF`/`TP`、`CTU`/`CTD`、`RS`/`SR` 等）与自定义块定义。
- 映射关系：FBD ↔ ST 常见互转（块调用/表达式），确保 PLCopen XML 的一致性与互导。

## IR 与执行模型
- IR 统一：表达式/块/连线/变量/端口/任务/程序单元，携带调度与类型元数据。
- 执行模型：scan cycle 驱动，拓扑排序执行；反馈通过状态节点断环（上一周期输出）。
- 静态分析：未初始化、类型不匹配、死代码、不可解析环等诊断。

## 编译与仿真
- 编译管线：AST → IR → 类型/拓扑/静态检查 → 可执行计划（.NET 运行时）。
- 仿真：系统时钟、定时器/计数器、I/O 模拟、断点/单步/暂停/继续；变量监视与趋势曲线。
- 可视化：FBD 在线端口数值、事件/日志面板、性能采样（周期耗时）。

## PLCopen XML 导入/导出
- 覆盖：Project/Resources/Configuration/POU（Program/Function/Function Block）/变量/任务/Body（ST/FBD）。
- 实现：`System.Xml.Linq` + XSD 校验；AST/IR 与 XML 双向映射保持结构/注释。
- 兼容策略：遵循 TC6 Schema；供应商扩展通过命名空间保留，避免信息丢失。
- 互导用例：与 CODESYS/TwinCAT 的 XML 进行导入/导出冒烟与金样验证。

## UI 功能
- 项目树：工程/资源/POU/库，增删改与重命名。
- ST 编辑器：高亮、错误提示、格式化、代码片段、导航与搜索。
- FBD 编辑器：块面板、连线编辑、参数面板、布局与对齐、自动整线/避障。
- 仿真视图：变量表、强制/释放、时间轴、断点/步进、周期配置。
- 构建面板：编译/诊断列表、XML 导入/导出、打包设置。

## 打包与跨平台交付
- Electron 打包产物：Windows（msi/exe）、macOS（dmg）、Linux（AppImage/deb/rpm）。
- 后端部署：随应用一并分发 .NET 8 自包含（self-contained）运行时；Electron 启动时拉起 Kestrel 服务。
- 版本与更新：自动更新（差分）、崩溃日志收集、用户数据目录安全存储。

## 测试与验证
- 单元测试：解析/类型/编译/仿真；PLCopen XML 导入/导出不变性（金样）。
- 集成测试：端到端项目编辑→编译→仿真→导出→外部工具导入验证。
- 跨平台 CI：Windows/macOS/Linux 的构建与测试矩阵。

## 里程碑
- M1：骨架搭建（Electron + React + ASP.NET Core）、Monaco ST 高亮、React Flow FBD 原型、最小 AST/IR、最小 PLCopen 导出（POU+变量）。
- M2：ST 解析器与类型检查、FBD 合法性与调度、仿真运行时（scan/定时器/变量监视）、PLCopen XML 导入与 XSD 校验。
- M3：完整 LSP 能力、标准库块集与互操作（ST↔FBD）、互导兼容性加固、跨平台打包与自动更新。

## 风险与缓解
- 供应商差异：以 PLCopen 为核心，扩展命名空间保留信息；提供供应商特性插件层。
- 桌面壳复杂度：采用 Electron 的成熟生态简化跨平台交付；后端走自包含发布降低环境依赖。
- 性能与资源：关键路径（解析/编译/仿真）使用 .NET 原生优化；前端交互（FBD）控制重绘与节点量级。

## 下一步
- 初始化仓库与三层骨架（前端/后端/壳），完成 M1 范围。
- 明确优先互导目标（例如先对齐 CODESYS/TwinCAT 的 XML）。
- 列出必需标准库块与示例工程，进入实现与测试。
 - 建立最小可用后端：`Plc.Server` Minimal API + SignalR，提供项目/文件 CRUD、编译入口与仿真控制。
 - 初始化语言与 IR：`Plc.Language.St` ANTLR4 语法骨架、`Plc.Language.Fbd` 模型与验证占位，定义基础 IR/类型集合。
 - 前端搭建：Vite + TS 初始化，引入 Monaco/React Flow；实现项目树、ST/FBD 编辑器容器与后端联通（保存/编译/诊断）。
 - Electron 壳：启动后端进程管理、打包配置与日志；预留自动更新。
 - LSP 原型：实现 ST 的诊断/跳转定义/悬浮的最小能力，并在前端接入。
 - PLCopen 导出：完成 POU + 变量的导出与 XSD 校验流水线，增加冒烟用例。
 - CI/CD 初始化：配置跨平台构建与测试矩阵（Windows/macOS/Linux），接入 xUnit/Vitest 套件。
 - 兼容性试点：与 CODESYS/TwinCAT 的 XML 互导金样比对，记录差异与兼容策略。
 - M1 交付清单：前端（Monaco 高亮、React Flow 原型）、后端（最小 AST/IR、API 通路）、PLCopen（最小导出）、测试（基础套件）。
 - 推进机制：每周演示与冒烟，问题清单/燃尽图，风险项跟踪与缓解。

## 当前完成度评估
- 框架骨架（M1）
  - 后端 Minimal API、CORS、基本路由与仿真服务：完成（≈100%）。
  - ST 解析与编译接口：最小可用，含变量域/行号、未声明引用检查（≈80%）。
  - FBD 画布与持久化：节点/连线/撤销重做/变量绑定与保存加载（≈80%）。
  - PLCopen XML 导出/导入：POU/工程导出、FBD 网络导出/导入基础流程（≈70%）。
  - 前端 ST 编辑器：高亮、编译诊断标记、悬浮提示、跳转/重命名/查找引用（≈85%）。
  - 构建面板：编辑器与当前 POU 编译、工程编译汇总与导出（≈70%）。
- 能力增强（M2）
  - ST 类型规则与更完整语法（控制流/表达式/调用）：进行中（≈40%）。
  - FBD 合法性与调度完善（端口类型推断/反馈环规范）：进行中（≈50%）。
  - 仿真运行时：基础变量快照/周期定时，未接入 FBD/POU 执行图（≈30%）。
  - PLCopen XML 导入与 XSD 校验：导出已覆盖主路径，导入与校验需要补强（≈50%）。
- LSP 能力（M3）
  - 跳转定义/查找引用/重命名：原型完成（≈70%），需作用域/语义精度提升。
  - 智能补全/签名/诊断统一：未开始或初步（≈20%）。
- 交付与工程化
  - Electron 打包与自包含 .NET：未接入（≈10%）。
  - CI/CD（多平台构建/测试矩阵）：未接入（≈10%）。

## 架构风格与代码设计模式（新增要求）
- 后端架构风格
  - 分层/整洁架构：`Domain`（语言/IR/编译）、`Application`（用例服务：项目/编译/仿真）、`Infrastructure`（ASP.NET 路由、存储、XML 库）。
  - 端口-适配器（Hexagonal）：对外接口（HTTP/SignalR/LSP）通过端口抽象，XML/存储/仿真设备作为适配器实现，便于替换与扩展。
  - CQRS 轻量化：读（查询）与写（命令）在 Minimal API 层分离，后续可接入事件流与审计。
  - 依赖反转：`Application` 依赖接口，`Infrastructure` 注入实现；统一使用 DI 配置生命周期。
- 前端架构风格
  - 以功能域组织：`features/st`、`features/fbd`、`features/pou`、`features/build` 分域，减少耦合。
  - 状态管理：组件内局部 `useState` 与远端数据请求分离；后续引入轻量状态容器（如 Zustand）用于跨功能共享。
  - UI/服务分层：视图组件（UI）与服务（HTTP/LSP 访问）、模型（FBD/ST 结构）拆分。
- 关键设计模式
  - 解析与编译：`Visitor`（AST/IR 遍历）、`Builder`（FBD/ST→PLCopen 构建）、`Strategy`（类型规则与校验策略）、`Factory`（节点/端口/块创建）。
  - LSP 原型：`Command`（重命名/跳转操作封装）、`Facade`（前端统一调用后端 LSP 端点）。
  - FBD 编辑器：`Command`（撤销/重做）、`Observer`（画布变更与自动保存）、`Adapter`（前端节点数据到后端 PLCopen 序列化）。
  - 仿真运行：`State Machine`（周期驱动与块状态）、`Observer`（变量快照推送）、`Strategy`（块执行逻辑）。
  - 存储与互导：`Repository`（工作区/POU/变量持久化抽象）、`Adapter`（供应商扩展 XML 命名空间）。
- 横切关注点
  - 日志：统一结构化日志（后端 `ILogger`，前端控制台分级），记录编译/导入/导出/仿真事件。
  - 错误与诊断：后端将语义/类型/拓扑诊断标准化（severity/code/message/range），前端统一渲染与导航。
  - 配置：端口/路径/特性开关集中管理，避免散落常量。
  - 测试：xUnit（解析/类型/编译/仿真）、Vitest（组件/交互）；增加金样测试（XML 导入/导出不变性）。
  - 安全：避免日志泄露用户工程内容与路径；持久化文件路径白名单化与规范化。

## 近期落地建议
- 扩展 ST 解析覆盖与类型规则，完善 LSP 语义精度（同域/同块约束）。
- FBD 合法性检查与执行拓扑的标准化输出，接入仿真运行时。
- 构建面板统一“问题列表”，支持跳转到 ST/FBD 具体位置。
- 接入 XSD 校验与互导金样比对，持续修正兼容性差异。
- 引入轻量状态容器与服务抽象，降低前端跨模块耦合。
